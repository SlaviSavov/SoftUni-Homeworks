﻿# Exercises: Iterators And ComparatorsProblems for exercises and homework for the  [&quot;CSharp Advanced&quot; course @ Software University](https://softuni.bg/courses/csharp-advanced).#**01.ListyIterator**Create a generic class ListyIterator. The collection, which it will iterate through, should be received in the constructor. You should store the elements in a List. The class should have three main functions:- Move - should move an internal index position to the next index in the list. The method should return true, if it had successfully moved the index and false if there is no next index.- HasNext - should return true, if there is a next index and false, if the index is already at the last element of the list.- Print - should print the element at the current internal index. Calling Print on a collection without elements should throw an appropriate exception with the message "Invalid Operation!". Your program should catch any exceptions thrown because of the described validations - calling Print on an empty collection - and print their messages instead.#**02.Collection**Using the ListyIterator from the last problem, extend it by implementing the IEnumerable<T> interface, implement all methods desired by the interface manually. Use yield return for the GetEnumerator() method. Add a new command PrintAll that should foreach the collection and print all of the elements on a single line separated by a space. Your program should catch any exceptions thrown because of validations and print their messages instead.#**03.Stack**Since you have passed the basic algorithms course, now you have a task to create your custom stack. You are aware of the Stack's structure. There is a collection to store the elements and two functions (not from the functional programming) - to push an element and to pop it. Keep in mind that the first element, which is popped is the last in the collection. The Push method adds an element at the top of the collection and the Pop method returns the top element and removes it. Push and Pop will be the only commands and they will come in the following format:"Push {element1}, {element2}, … {elementN} PopWrite your custom implementation of Stack<T> and implement IEnumerable<T> interface. Your implementation of the GetEnumerator() method should follow the rules of the Abstract Data Type – Stack (return the elements in reverse order of adding them to the stack).#**04.Froggy**Let's play a game. You have a tiny little Frog, and a Lake that has a path of stones in it. Every stone has a number. Our frog must cross the lake along that path and then return. But there are some rules. First, the frog must jump on all the stones, which are in even positions in ascending order and then on all the odd ones, but in reversed order. The order of the stones and their numbers will be given on the first line of input. Then you must print the order of stones in which our frog jumped from one to another.#**05.Comparing Objects**Create a class Person. Each person should have a name, an age and a town. You should implement the interface – IComparable<T> and implement the CompareTo method. When you compare two people, first you should compare their names, after that – their age and finally – their towns. You will be receiving input with information about the people, until you receive the "END" command in the following format:"{name} {age} {town}"After that, you will receive n – the n'th person from your collection, starting from 1. You should bring statistics, how many people are equal to him, how many people are not equal to him and the total people in your collection in the following format:"{number of equal people} {number of not equal people} {total number of people}"If there are no equal people print: "No matches".#**06.Equality Logic**Create a class Person holding a name and an age. A person with the same name and age should be considered the same. Override any methods needed to enforce this logic. Your class should work with both standard and hashed collections. Create a SortedSet and a HashSet of type Person. You will receive n – the number of input lines. On each of them, you will receive info about the people in the following format:"<name> <age>"You should add the people to both the sets. In the end, you should print the size of the tree set and then the size of the hashset.#**07. Custom Linked List**Extend your custom linked list, which is already generic, and implement the needed interfaces to make it foreach-able. Upload your solutions in a zip file without the bin and obj folders in Judge.